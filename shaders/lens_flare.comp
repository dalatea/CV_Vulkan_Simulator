#version 450

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D flareImg;

struct LensSurface {
    float radius;
    float z;
    float ior;
    float aperture;
    int   isStop;
};

layout(set = 0, binding = 1) readonly buffer Surfaces {
    LensSurface s[];
};

layout(set = 0, binding = 2) uniform LensParams {
    int   surfaceCount;
    float sensorZ;
    float sensorW;
    float sensorH;
    float pad0;
} lp;

layout(set = 0, binding = 3) uniform GlobalUbo {
    mat4 projection;
    mat4 view;
    mat4 invView;
    mat4 lightViewProj;

    vec4 ambientLightColor;

    vec4 sunParams;
    vec4 sunScreen; // xy sunUV, z visibility, w scale
    

} ubo;


// --------------------- math ---------------------

bool refractRay(in vec3 I, in vec3 N, float eta, out vec3 T) {
    float cosi = clamp(dot(-I, N), -1.0, 1.0);
    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);
    if (k < 0.0) return false;
    T = normalize(eta * I + (eta * cosi - sqrt(k)) * N);
    return true;
}

vec3 reflectRay(vec3 I, vec3 N) {
    return normalize(I - 2.0 * dot(I, N) * N);
}


bool intersectSphereSurface(vec3 ro, vec3 rd, float radius, float zSurf, out vec3 hitPos, out vec3 N) {
    float R = radius;

    vec3 C = vec3(0.0, 0.0, zSurf + R);

    vec3 oc = ro - C;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - R * R;
    float disc = b * b - c;
    if (disc < 0.0) return false;

    float t = -b - sqrt(disc);
    if (t < 0.0) t = -b + sqrt(disc);
    if (t < 0.0) return false;

    hitPos = ro + rd * t;
    N = normalize(hitPos - C);

    if (R < 0.0) N = -N;

    return true;
}

bool passAperture(vec3 p, float apertureRadius) {
    return (p.x * p.x + p.y * p.y) <= (apertureRadius * apertureRadius);
}

// --------------------- main ---------------------

void main() {
    imageStore(flareImg, ivec2(gl_GlobalInvocationID.xy), vec4(0,1,0,1));
    /*ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(flareImg);
    if (pix.x >= size.x || pix.y >= size.y) 
    {
    	imageStore(flareImg, pix, vec4(
    	1,
    	0,
        0.0,
        1.0
    ));
    return;
}



    vec2 uv = (vec2(pix) + 0.5) / vec2(size);

    vec2 sunUV = ubo.sunScreen.xy;

    float sunR = 0.02; 

    float dSun = length(uv - sunUV);
    //if (dSun > 0.25) return; 

    const int SUN_SAMPLES = 8;
    const int AP_SAMPLES = 16;

    vec3 accum = vec3(0.0);

    uint seed = uint(pix.x * 1973 + pix.y * 9277) ^ 0x68bc21u;

    float sunIntensity = ubo.sunColor.a; 
    vec3  sunCol = ubo.sunColor.rgb;

    for (int si = 0; si < SUN_SAMPLES; ++si) {
        float a = float(si) / float(SUN_SAMPLES) * 6.28318;
        float r = sunR * (0.3 + 0.7 * fract(sin(float(seed + si) * 12.9898) * 43758.5453));
        vec2 sunPoint = sunUV + vec2(cos(a), sin(a)) * r;

        vec3 dirFromSun = normalize(-ubo.sunDirection.xyz); 

        for (int ai = 0; ai < AP_SAMPLES; ++ai) {

            float u = fract(sin(float(seed + ai * 13u) * 12.9898) * 43758.5453);
            float v = fract(sin(float(seed + ai * 29u) * 78.233) * 12345.6789);
            float ang = 6.28318 * u;
            float rad = sqrt(v);

            float apR = 0.01;
            float apZ = 0.0;
            for (int k = 0; k < lp.surfaceCount; ++k) {
                if (s[k].isStop == 1) {
                    apR = s[k].aperture;
                    apZ = s[k].z;
                    break;
                }
            }

            vec2 apXY = vec2(cos(ang), sin(ang)) * rad * apR;

            vec3 ro = vec3(apXY, apZ);
            vec3 rd = dirFromSun;


            float n1 = 1.0; 

            bool killed = false;

            for (int k = 0; k < lp.surfaceCount; ++k) {
                vec3 hp, N;
                if (!intersectSphereSurface(ro, rd, s[k].radius, s[k].z, hp, N)) {
                    killed = true; break;
                }

                if (s[k].isStop == 1) {
                    if (!passAperture(hp, s[k].aperture)) {
                        killed = true; break;
                    }
                }

                float n2 = s[k].ior;
                vec3 refr;
                float eta = n1 / n2;

                if (!refractRay(rd, N, eta, refr)) {
                    killed = true; break;
                }

                ro = hp + refr * 1e-4;
                rd = refr;
                n1 = n2;
            }

            if (killed) continue;

            int g = max(lp.surfaceCount - 2, 0);

            {
                vec3 hp, N;
                if (intersectSphereSurface(ro, rd, s[g].radius, s[g].z, hp, N)) {
                    vec3 rdir = reflectRay(rd, N);

                    vec3 rro = hp + rdir * 1e-4;
                    vec3 rrd = rdir;

                    float t = (lp.sensorZ - rro.z) / rrd.z;
                    if (t > 0.0) {
                        vec3 sp = rro + rrd * t;

                        vec2 suv = vec2(
                            0.5 + sp.x / lp.sensorW,
                            0.5 + sp.y / lp.sensorH
                        );

                        float w = 1.0 / float(SUN_SAMPLES * AP_SAMPLES);
                        float fall = exp(-dSun * 8.0);

                        float refl = 0.04;

                        float d = length(suv - uv);
                        float kernel = exp(-d * 200.0);

                        accum += sunCol * sunIntensity * refl * fall * kernel * w;
                    }
                }
            }
        }
    }

    if (length(accum) > 0.0) {
        vec4 prev = imageLoad(flareImg, pix);
        imageStore(flareImg, pix, prev + vec4(accum, 1.0));
    }*/
}
